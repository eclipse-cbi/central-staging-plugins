/*
 * Copyright (c) 2025 Eclipse Foundation and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * // Some portions generated by Co-Pilot
 */

package org.eclipse.cbi.central.plugin;

import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.project.MavenProject;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.model.Model;
import org.apache.maven.shared.invoker.Invoker;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.shared.invoker.InvocationRequest;
import org.apache.maven.shared.invoker.InvocationResult;
import org.apache.maven.shared.invoker.DefaultInvocationRequest;
import org.apache.maven.shared.invoker.MavenInvocationException;
import org.apache.maven.plugin.MojoFailureException;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * Abstract base class for staging-related mojos with common constants and properties.
 */
public abstract class AbstractStagingMojo extends AbstractCentralMojo {

    // ================================================================================================
    // SHARED CONSTANTS
    // ================================================================================================

    /** Default bundle file name */
    protected static final String DEFAULT_BUNDLE_NAME = "deployment-staging.zip";
    /** Boolean false value for Maven properties */
    protected static final String FALSE = "false";

    // Packaging Types
    /** POM packaging type */
    protected static final String POM_PACKAGING = "pom";
    /** Eclipse repository packaging type */
    protected static final String ECLIPSE_REPOSITORY_PACKAGING = "eclipse-repository";
    /** Eclipse feature packaging type */
    protected static final String ECLIPSE_FEATURE_PACKAGING = "eclipse-feature";
    /** Eclipse plugin packaging type */
    protected static final String ECLIPSE_PLUGIN_PACKAGING = "eclipse-plugin";

    // File Extensions
    /** POM file extension */
    protected static final String POM_EXTENSION = ".pom";
    /** JAR file extension */
    protected static final String JAR_EXTENSION = ".jar";
    /** ZIP file extension */
    protected static final String ZIP_EXTENSION = ".zip";
    /** GPG signature file extension */
    protected static final String ASC_EXTENSION = ".asc";
    /** MD5 checksum file extension */
    protected static final String MD5_EXTENSION = ".md5";
    /** SHA-1 checksum file extension */
    protected static final String SHA1_EXTENSION = ".sha1";
    /** SHA-256 checksum file extension */
    protected static final String SHA256_EXTENSION = ".sha256";
    /** SHA-512 checksum file extension */
    protected static final String SHA512_EXTENSION = ".sha512";

    // File Suffixes
    /** Sources JAR file suffix */
    protected static final String SOURCES_JAR_SUFFIX = "-sources.jar";
    /** Javadoc JAR file suffix */
    protected static final String JAVADOC_JAR_SUFFIX = "-javadoc.jar";
    /** P2 artifacts file suffix */
    protected static final String P2_ARTIFACTS_SUFFIX = "-p2artifacts.xml";
    /** P2 metadata file suffix */
    protected static final String P2_METADATA_SUFFIX = "-p2metadata.xml";

    // Classifier Constants
    /** Sources classifier */
    protected static final String SOURCES_CLASSIFIER = ":sources";
    /** Javadoc classifier */
    protected static final String JAVADOC_CLASSIFIER = ":javadoc";

    // Artifact Specifications
    /** Main JAR artifact specification */
    protected static final String JAR_SPEC = ":jar";
    /** Main ZIP artifact specification */
    protected static final String ZIP_SPEC = ":zip";
    /** POM artifact specification */
    protected static final String POM_SPEC = ":pom";
    /** Sources JAR artifact specification */
    protected static final String JAR_SOURCES_SPEC = ":jar:sources";
    /** Javadoc JAR artifact specification */
    protected static final String JAR_JAVADOC_SPEC = ":jar:javadoc";
    /** P2 artifacts metadata specification */
    protected static final String P2_ARTIFACTS_SPEC = ":xml:p2artifacts";
    /** P2 content metadata specification */
    protected static final String P2_METADATA_SPEC = ":xml:p2metadata";

    // ================================================================================================
    // SHARED CONFIGURATION PARAMETERS
    // ================================================================================================

    // Remote Repository Configuration
    /**
     * Server ID in settings.xml to use for authentication to the remote repository.
     */
    @Parameter(property = "central.serverSyncId", defaultValue = "central.sync")
    protected String serverSyncId;

    /**
     * URL of the remote repository to download artifacts from.
     */
    @Parameter(property = "central.repositoryUrl")
    protected String repositoryUrl;

    /**
     * Layout of the remote repository (default or legacy).
     */
    @Parameter(property = "central.repositoryLayout", defaultValue = "default")
    protected String repositoryLayout;

    // GAV Configuration
    /**
     * Namespace (groupId) to process. If not set, uses current project.
     */
    @Parameter(property = "central.namespace")
    protected String namespace;

    /**
     * Name (artifactId) to process. If not set, uses current project.
     */
    @Parameter(property = "central.name")
    protected String name;

    /**
     * Version to process. If not set, uses current project.
     */
    @Parameter(property = "central.version")
    protected String version;

    // File and Directory Configuration
    /**
     * Staging directory name for downloaded artifacts before bundling.
     */
    @Parameter(property = "central.syncStagingDirName", defaultValue = "sync-staging")
    protected String syncStagingDirName;

    /**
     * Staging directory for downloaded artifacts before bundling.
     */
    @Parameter(property = "central.syncStagingDir", defaultValue = "${project.build.directory}")
    protected String syncStagingDir;

    /**
     * Output bundle file (zip).
     */
    @Parameter(property = "central.syncBundleFile", defaultValue = "${project.build.directory}/" + DEFAULT_BUNDLE_NAME)
    protected File syncBundleFile;

    /**
     * The bundle name to use for the upload. If not specified, defaults to the
     * artifact filename without extension.
     */
    @Parameter(property = "central.bundleName")
    protected String bundleName;

    // Execution Mode Configuration
    /**
     * If true, only simulate actions without performing them.
     */
    @Parameter(property = "central.dryRun", defaultValue = "false")
    protected boolean dryRun;

    /**
     * If true, skip the download phase entirely.
     */
    @Parameter(property = "central.skipDownload", defaultValue = "false")
    protected boolean skipDownload;

    // Artifact Processing Configuration
    /**
     * Generate MD5/SHA1 checksum files for each artifact if missing.
     */
    @Parameter(property = "central.generateChecksums", defaultValue = "true")
    protected boolean generateChecksums;

    /**
     * If true, force regenerating checksum files even if they are already present.
     */
    @Parameter(property = "central.forceGenerateChecksums", defaultValue = "false")
    protected boolean forceGenerateChecksums;

    /**
     * Generate SHA-256 checksum files for each artifact if missing.
     */
    @Parameter(property = "central.generateChecksums256", defaultValue = "false")
    protected boolean generateChecksums256;

    /**
     * Generate SHA-512 checksum files for each artifact if missing.
     */
    @Parameter(property = "central.generateChecksums512", defaultValue = "false")
    protected boolean generateChecksums512;

    /**
     * If true, sign artifacts with GPG when their .asc is missing.
     */
    @Parameter(property = "central.signArtifacts", defaultValue = "true")
    protected boolean signArtifacts;

    /**
     * If true, force resigning artifacts even if .asc files are present.
     */
    @Parameter(property = "central.forceSignArtifacts", defaultValue = "false")
    protected boolean forceSignArtifacts;
    
   /**
     * Whether to automatically publish the deployment after validation.
     * If true, the deployment will automatically progress to PUBLISHING when validation passes (AUTOMATIC mode).
     * If false, the deployment will stop in VALIDATED state and require manual approval (USER_MANAGED mode).
     */
    @Parameter(property = "central.automaticPublishing", defaultValue = "false")
    protected boolean automaticPublishing;

    /**
     * If true, also process P2 repository metadata files.
     */
    @Parameter(property = "central.p2Metadata", defaultValue = "false")
    protected boolean p2Metadata;

    // Download Configuration
    /**
     * If true, attempt to download GPG signature files (.asc) for each artifact.
     */
    @Parameter(property = "central.downloadSignatures", defaultValue = "true")
    protected boolean downloadSignatures;

    /**
     * If true, attempt to download MD5/SHA1 checksum files for each artifact.
     */
    @Parameter(property = "central.downloadChecksums", defaultValue = "true")
    protected boolean downloadChecksums;

    /**
     * If true, attempt to download SHA-256 checksum files for each artifact.
     */
    @Parameter(property = "central.downloadChecksums256", defaultValue = "false")
    protected boolean downloadChecksums256;

    /**
     * If true, attempt to download SHA-512 checksum files for each artifact.
     */
    @Parameter(property = "central.downloadChecksums512", defaultValue = "false")
    protected boolean downloadChecksums512;

    // Failure Handling Configuration
    /**
     * If true, fail the build when sources or javadoc artifacts cannot be processed.
     */
    @Parameter(property = "central.failOnMissingSourcesJavadoc", defaultValue = "false")
    protected boolean failOnMissingSourcesJavadoc;

    /**
     * If true, fail the build when GPG signature files (.asc) cannot be processed.
     */
    @Parameter(property = "central.failOnMissingSignatureFile", defaultValue = "false")
    protected boolean failOnMissingSignatureFile;

    /**
     * If true, fail the build when checksum files cannot be processed.
     */
    @Parameter(property = "central.failOnMissingChecksum", defaultValue = "false")
    protected boolean failOnMissingChecksum;

    // Output Configuration
    /**
     * If true, display Maven goal execution output for debugging.
     */
    @Parameter(property = "central.showMavenGoalOutput", defaultValue = "false")
    protected boolean showMavenGoalOutput;
    
    /**
     * Maximum wait time in seconds for validation to complete.
     */
    @Parameter(property = "central.maxWaitTime", defaultValue = "300")
    protected int maxWaitTime;

    /**
     * Maximum wait time in seconds for publishing to complete.
     */
    @Parameter(property = "central.maxWaitTimePublishing", defaultValue = "600")
    protected int maxWaitTimePublishing;

    /**
     * Polling interval in seconds when checking deployment status.
     */
    @Parameter(property = "central.pollInterval", defaultValue = "5")
    protected int pollInterval;

    /**
     * If true, wait for the complete publishing process to finish.
     * If false, return after validation is complete (for USER_MANAGED) or after publishing starts (for AUTOMATIC).
     */
    @Parameter(property = "central.waitForCompletion", defaultValue = "false")
    protected boolean waitForCompletion;

    // ================================================================================================
    // SHARED INJECTED MAVEN COMPONENTS
    // ================================================================================================

    /**
     * Reactor projects for multi-module build (injected by Maven).
     */
    @Parameter(defaultValue = "${reactorProjects}", readonly = true)
    protected List<MavenProject> reactorProjects;

    /**
     * Maven session (injected by Maven).
     */
    @Parameter(defaultValue = "${session}", readonly = true)
    protected MavenSession session;

    /**
     * Maven invoker for executing Maven goals (injected by Maven).
     */
    @Component
    protected Invoker invoker;

    /**
     * Maven execution context (injected by Maven).
     */
    @Parameter(defaultValue = "${mojoExecution}", readonly = true)
    protected MojoExecution mojoExecution;

    // ================================================================================================
    // SHARED UTILITY METHODS
    // ================================================================================================
    
    /**
     * Resolves the target projects to process based on provided parameters.
     * If explicit GAV is provided, creates a synthetic project.
     * Otherwise, uses reactor projects or falls back to current project.
     * 
     * @return List of Maven projects to process
     */
    protected List<MavenProject> resolveTargetProjects() {
        // If explicit GAV is provided, create a synthetic Maven project
        if (this.namespace != null && !this.namespace.isBlank() && this.name != null && !this.name.isBlank()
                && this.version != null && !this.version.isBlank()) {
            getLog().info("Explicit GAV provided: " + this.namespace + ":" + this.name + ":" + this.version);
            Model model = new Model();
            model.setGroupId(this.namespace);
            model.setArtifactId(this.name);
            model.setVersion(this.version);
            // Default to jar packaging for explicit GAV unless we can determine otherwise
            model.setPackaging("jar");
            return List.of(new MavenProject(model));
        }

        // If we have a project, use reactor projects if present
        if (this.project != null) {
            if (this.reactorProjects != null && !this.reactorProjects.isEmpty()) {
                List<MavenProject> result = new ArrayList<>();
                for (MavenProject rp : this.reactorProjects) {
                    if (rp != null) {
                        result.add(rp);
                    }
                }
                getLog().info("Resolved " + result.size() + " reactor projects for download step.");
                return result;
            }
            // Fallback to current project
            return List.of(this.project);
        }

        // This should not happen due to the check in resolveEffectiveGav
        throw new IllegalStateException("No target projects could be resolved");
    }

    /**
     * Checks if the packaging type is an Eclipse-specific packaging that should include P2 metadata.
     * 
     * @param packaging The packaging type to check
     * @return true if it's an Eclipse packaging type
     */
    protected boolean isEclipsePackaging(String packaging) {
        return ECLIPSE_REPOSITORY_PACKAGING.equals(packaging) ||
                ECLIPSE_FEATURE_PACKAGING.equals(packaging) ||
                ECLIPSE_PLUGIN_PACKAGING.equals(packaging);
    }

    /**
     * Resolves the effective GAV (Group:Artifact:Version) coordinates.
     * Uses provided parameters or falls back to current project coordinates.
     * 
     * @return Array containing [groupId, artifactId, version]
     */
    protected String[] resolveEffectiveGav() {
        // If explicit GAV parameters are provided, use them
        if (this.namespace != null && !this.namespace.isBlank()
                && this.name != null && !this.name.isBlank()
                && this.version != null && !this.version.isBlank()) {
            return new String[] { this.namespace, this.name, this.version };
        }

        // Otherwise, fall back to project coordinates if available
        if (this.project != null) {
            String effectiveNamespace = this.namespace != null && !this.namespace.isBlank() ? this.namespace
                    : this.project.getGroupId();
            String effectiveName = this.name != null && !this.name.isBlank() ? this.name : this.project.getArtifactId();
            String effectiveVersion = this.version != null && !this.version.isBlank() ? this.version
                    : this.project.getVersion();
            return new String[] { effectiveNamespace, effectiveName, effectiveVersion };
        }

        // If no project and no explicit GAV, we can't proceed
        throw new IllegalStateException("No project found and no explicit GAV coordinates provided. " +
                "Please provide central.namespace, central.name, and central.version parameters.");
    }

    /**
     * Prepares the staging directory for downloaded artifacts.
     * 
     * @return The staging directory path as a string
     */
    protected String prepareStagingDirectory() {
        String stagingPath;
        if ((this.session.getRequest() != null && !this.session.getRequest().isProjectPresent())) {
            stagingPath = System.getProperty("user.dir") + "/" + this.syncStagingDirName;
        } else {
            stagingPath = this.syncStagingDir + "/" + this.syncStagingDirName;
        }
        return stagingPath;
    }

    /**
     * Determines the effective path for the bundle file.
     * 
     * @return The effective bundle file path
     */
    protected File effectiveBundlePath() {
        if (this.syncBundleFile != null) {
            return this.syncBundleFile;
        }
        if (this.project != null && this.project.getBuild() != null) {
            return new File(this.project.getBuild().getDirectory(), DEFAULT_BUNDLE_NAME);
        }
        return new File(System.getProperty("user.dir"), DEFAULT_BUNDLE_NAME);
    }

    /**
     * Executes a Maven goal with the specified properties and handles common error scenarios.
     * 
     * @param goal         The Maven goal to execute (e.g., "dependency:get", "dependency:copy")
     * @param properties   The properties to pass to the goal
     * @param packaging    The packaging type of the artifact for error handling
     * @param artifactSpec The artifact specification for error messages
     * @return true if the execution succeeded, false if it failed
     * @throws MojoFailureException if the Maven goal execution fails
     */
    protected boolean executeMavenGoal(String goal, java.util.Properties properties, String packaging,
            String artifactSpec) throws MojoFailureException {
        InvocationResult result = null;
        try {
            // Create the invocation request
            InvocationRequest request = new DefaultInvocationRequest();

            // Only set POM file if we have a project
            if (this.project != null && this.session != null && session.getRequest().isProjectPresent()) {
                request.setPomFile(this.session.getCurrentProject().getFile());
            }

            request.addArg("-q"); // Quiet mode to suppress reactor summary
            request.addArg("-B"); // Batch mode (non-interactive)
            request.addArg(goal);
            request.setProperties(properties);

            // Control output visibility based on configuration
            if (!this.showMavenGoalOutput) {
                // Suppress interactive mode warning by providing empty input stream
                request.setInputStream(new java.io.ByteArrayInputStream(new byte[0]));

                // Suppress output by redirecting to null output handler
                request.setOutputHandler(line -> {
                    // Suppress all output - do nothing with the line
                });

                request.setErrorHandler(line -> {
                    // Suppress all error output - do nothing with the line
                });
            }

            // Execute the Maven goal
            result = this.invoker.execute(request);

        } catch (MavenInvocationException e) {
            throw new MojoFailureException("Failed to execute " + goal + " for " + artifactSpec, e);
        }

        if (result != null && result.getExitCode() != 0) {
            handleFailure(artifactSpec, packaging,
                    new Exception(goal + " failed with exit code: " + result.getExitCode() + ", Exception: "
                            + (result.getExecutionException() != null
                                    ? result.getExecutionException()
                                    : "none")));
            return false;
        } else {
            getLog().info(goal + " executed successfully for " + artifactSpec);
            return true;
        }
    }

    /**
     * Handles Maven goal execution failures for different types of artifacts and files.
     * This method should be overridden by subclasses to provide specific error handling.
     * 
     * @param artifactSpec The artifact specification that failed
     * @param packaging    The packaging type of the artifact
     * @param cause        The exception that caused the failure
     * @throws MojoFailureException if the failure should cause the build to fail
     */
    protected void handleFailure(String artifactSpec, String packaging, Exception cause)
            throws MojoFailureException {

        // Classify the type of artifact that failed to download
        boolean isSourcesArtifact = artifactSpec.contains(SOURCES_CLASSIFIER);
        boolean isJavadocArtifact = artifactSpec.contains(JAVADOC_CLASSIFIER);
        boolean isSignatureFile = artifactSpec.contains(ASC_EXTENSION);
        boolean isChecksumFile = isChecksumFile(artifactSpec);

        // Handle each type of failure according to configuration
        if (isSignatureFile) {
            handleSignatureFileFailure(artifactSpec, cause);
        } else if (isChecksumFile) {
            handleChecksumFileFailure(artifactSpec, cause);
        } else if (isSourcesArtifact || isJavadocArtifact) {
            handleSourcesJavadocFailure(artifactSpec, packaging, cause,
                    isSourcesArtifact ? "Sources" : "Javadoc");
        } else {
            // Not an optional artifact type, propagate the failure
            throw new MojoFailureException("Failed goal with artifact: " + artifactSpec, cause);
        }
    }

    /**
     * Checks if the artifact specification represents a checksum file.
     * 
     * @param artifactSpec The artifact specification to check
     * @return true if it's a checksum file (.md5, .sha1, .sha256, .sha512)
     */
    private boolean isChecksumFile(String artifactSpec) {
        return artifactSpec.contains(MD5_EXTENSION) ||
                artifactSpec.contains(SHA1_EXTENSION) ||
                artifactSpec.contains(SHA256_EXTENSION) ||
                artifactSpec.contains(SHA512_EXTENSION);
    }

    /**
     * Handles failures when downloading GPG signature files (.asc).
     * 
     * @param artifactSpec The signature file specification that failed
     * @param cause        The exception that caused the failure
     * @throws MojoFailureException if failOnMissingSignatureFile is true
     */
    private void handleSignatureFileFailure(String artifactSpec, Exception cause) throws MojoFailureException {
        if (this.failOnMissingSignatureFile) {
            throw new MojoFailureException("GPG signature file required but not found: " + artifactSpec, cause);
        }
        getLog().warn("GPG signature file not found (optional): " + artifactSpec + ", cause: " + cause.getMessage());
    }

    /**
     * Handles failures when downloading checksum files (.md5, .sha1, .sha256,
     * .sha512).
     * 
     * @param artifactSpec The checksum file specification that failed
     * @param cause        The exception that caused the failure
     * @throws MojoFailureException if failOnMissingChecksum is true
     */
    private void handleChecksumFileFailure(String artifactSpec, Exception cause) throws MojoFailureException {
        if (this.failOnMissingChecksum) {
            throw new MojoFailureException("Checksum file required but not found: " + artifactSpec, cause);
        }
        getLog().warn("Checksum file not found (optional): " + artifactSpec + ", cause: " + cause.getMessage());
    }

    /**
     * Handles failures when downloading sources or javadoc artifacts.
     * 
     * Behavior depends on packaging type:
     * - POM packaging: Always warns (sources/javadoc not expected)
     * - Eclipse repository packaging: Always warns (sources/javadoc typically not
     * available)
     * - Other packaging: Respects failOnMissingSourcesJavadoc setting
     * 
     * @param artifactSpec The sources/javadoc specification that failed
     * @param packaging    The packaging type of the main artifact
     * @param cause        The exception that caused the failure
     * @param artifactType The type name ("Sources" or "Javadoc") for logging
     * @throws MojoExecutionException if failOnMissingSourcesJavadoc is true for
     *                                non-POM packaging
     */
    private void handleSourcesJavadocFailure(String artifactSpec, String packaging, Exception cause,
            String artifactType)
            throws MojoFailureException {

        if (POM_PACKAGING.equals(packaging)) {
            // POM modules don't publish sources/javadoc, just warn
            getLog().warn(artifactType + " artifact not found for POM module (expected): " + artifactSpec);
        } else if (ECLIPSE_REPOSITORY_PACKAGING.equals(packaging) ||
                ECLIPSE_FEATURE_PACKAGING.equals(packaging) ||
                ECLIPSE_PLUGIN_PACKAGING.equals(packaging)) {
            // Eclipse modules typically don't publish sources/javadoc, just warn
            getLog().warn(
                    artifactType + " artifact not found for " + packaging + " module (expected): " + artifactSpec);
        } else if (this.failOnMissingSourcesJavadoc) {
            // User wants strict mode for non-POM modules
            throw new MojoFailureException(artifactType + " artifact required but not found: " + artifactSpec, cause);
        } else {
            // Default behavior: warn but continue
            getLog().warn(artifactType + " artifact not found (continuing): " + artifactSpec +
                    " (use failOnMissingSourcesJavadoc=true to fail instead)");
        }
    }

    // ================================================================================================
    // SHARED DRY-RUN LOGGING METHODS
    // ================================================================================================

    /**
     * Logs dry-run header information.
     */
    protected void logDryRunStart() {
        if (!dryRun)
            return;

        getLog().info("");
        getLog().info("=== DRY-RUN MODE ACTIVATED ===");
        getLog().info("No actual operations will be performed - showing execution plan");
        getLog().info("");
    }

    /**
     * Logs dry-run summary information.
     */
    protected void logDryRunSummary() {
        if (!dryRun)
            return;

        getLog().info("");
        getLog().info("=== DRY-RUN SUMMARY ===");
        getLog().info("All operations completed successfully in dry-run mode.");
        getLog().info("To execute these operations for real, run the same command without -Dcentral.dryRun=true");
        getLog().info("");
    }
}
