/*
 * Copyright (c) 2025 Eclipse Foundation and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * // Some portions generated by Co-Pilot
 */

package org.eclipse.cbi.central.plugin;

import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugin.MojoFailureException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.maven.project.MavenProject;
import org.apache.commons.codec.digest.DigestUtils;
import org.eclipse.aether.RepositorySystem;

@Mojo(name = "rc-bundle", defaultPhase = LifecyclePhase.NONE, requiresProject = false)
public class RcBundleMojo extends AbstractStagingMojo {

    /**
     * Maven Artifact Resolver system for downloading artifacts.
     * Injected by Maven and passed to RcDownloadMojo when needed.
     */
    @Component
    protected RepositorySystem repositorySystem;

    /**
     * If true, create a ZIP bundle from processed artifacts.
     */
    @Parameter(property = "central.zipArtifacts", defaultValue = "true")
    protected boolean zipArtifacts;

    /**
     * Main execution method for the rc-bundle Maven goal.
     * 
     * Creates a bundle from downloaded artifacts with optional download, checksum
     * generation,
     * and signing capabilities.
     * 
     * @throws MojoFailureException if any step in the bundle process fails
     */
    @Override
    public void execute() throws MojoFailureException {
        getLog().info("Starting rc-bundle goal");

        // Check if we have explicit GAV parameters or use project coordinates
        boolean hasExplicitGav = this.namespace != null && !this.namespace.isBlank()
                && this.name != null && !this.name.isBlank()
                && this.version != null && !this.version.isBlank();

        // Only check execution root if we're working with a project
        if (!hasExplicitGav && this.project != null && !this.project.isExecutionRoot()) {
            getLog().info("Skipping rc-bundle: not execution root");
            return;
        }

        String[] gav = resolveEffectiveGav();
        showConfig(gav);
        getLog().info("repositoryUrl: " + this.repositoryUrl);
        // First, call rc-download to download artifacts if needed
        if (this.repositoryUrl != null && !this.repositoryUrl.isBlank()) {
            getLog().info("Calling rc-download to download artifacts first...");
            executeRcDownload();
        } else {
            getLog().info("No repository URL specified, assuming artifacts are already downloaded");
        }

        // Resolve target projects for processing
        List<MavenProject> targetProjects = this.resolveTargetProjects();

        logDryRunStart();

        File bundle = buildBundleFromStaging(targetProjects);

        logDryRunSummary();

        getLog().info("Bundle creation completed successfully.");
        if (bundle != null) {
            getLog().info("Bundle created at: " + bundle.getAbsolutePath());
        } else {
            getLog().info("No bundle created in dry-run mode.");
        }
    }

    // ================================================================================================
    // BUNDLE BUILDING METHODS
    // ================================================================================================

    /**
     * Builds a bundle from staging directory by processing artifacts and creating a
     * ZIP file.
     * 
     * @param targetProjects List of Maven projects to process
     * @return The bundle file created from staged artifacts (null in dry-run mode)
     * @throws MojoFailureException if the bundle build fails
     */
    public File buildBundleFromStaging(List<MavenProject> targetProjects) throws MojoFailureException {
        File stagingDir = new File(prepareStagingDirectory());
        if (!stagingDir.exists()) {
            throw new MojoFailureException("Staging directory does not exist: " + stagingDir +
                    ". Make sure to run rc-download first or specify central.repositoryUrl to auto-download.");
        }

        if (this.dryRun) {
            logPostProcessing(this.generateChecksums, this.signArtifacts, this.zipArtifacts);
            return null;
        }

        // Generate missing checksums for downloaded artifacts
        if (this.generateChecksums) {
            getLog().info("Ensuring checksums for artifacts in " + stagingDir.getAbsolutePath());
            ensureDownloadedArtifactsChecksums(stagingDir, targetProjects);
        } else {
            getLog().warn("Skipping checksum generation");
        }

        displayChecksumsSummary(stagingDir, targetProjects);
        
        // Ensure downloaded artifacts are signed before creating the final bundle
        if (this.signArtifacts) {
            getLog().info("Ensuring signatures for artifacts in " + stagingDir.getAbsolutePath());
            ensureDownloadedArtifactsSigned(stagingDir, targetProjects);
        } else {
            getLog().warn("Skipping artifact signing");
        }

        // Create ZIP bundle if enabled
        if (this.zipArtifacts) {
            getLog().info("Creating bundle from staging directory: " + stagingDir.getAbsolutePath());
            try {
                return zipStaging(stagingDir, effectiveBundlePath());
            } catch (IOException e) {
                throw new MojoFailureException("Failed to create ZIP bundle", e);
            }
        } else {
            getLog().info("Artifacts processed in staging directory: " + stagingDir.getAbsolutePath());
            getLog().info("ZIP bundle creation skipped (central.zipArtifacts=false)");
            return null;
        }
    }

    /**
     * Displays a summary of all checksums for the artifacts.
     * 
     * @param stagingDir     The staging directory containing downloaded artifacts
     * @param targetProjects List of Maven projects to process
     * @throws MojoFailureException if reading checksums fails
     */
    private void displayChecksumsSummary(File stagingDir, List<MavenProject> targetProjects)
            throws MojoFailureException {
        getLog().info("========================================");
        getLog().info("Checksums Summary");
        getLog().info("========================================");

        for (MavenProject targetProject : targetProjects) {
            String groupId = targetProject.getGroupId();
            String artifactId = targetProject.getArtifactId();
            String projectVersion = targetProject.getVersion();

            // Build path to downloaded artifacts
            String groupPath = groupId.replace('.', '/');
            File artifactDir = new File(new File(new File(stagingDir, groupPath), artifactId), projectVersion);

            if (artifactDir.exists()) {
                getLog().info("");
                getLog().info("Project: " + groupId + ":" + artifactId + ":" + projectVersion);
                displayChecksumsForArtifactDir(artifactDir, artifactId, projectVersion, targetProject.getPackaging());
            }
        }

        getLog().info("========================================");
    }

    /**
     * Displays checksums for all artifacts in a directory.
     * 
     * @param artifactDir The directory containing the artifacts
     * @param artifactId  The artifact ID
     * @param version     The version of the artifact
     * @param packaging   The packaging type
     * @throws MojoFailureException if reading checksums fails
     */
    private void displayChecksumsForArtifactDir(File artifactDir, String artifactId, String version, String packaging)
            throws MojoFailureException {
        for (String artifactName : buildArtifactFileNames(artifactId, version, packaging)) {
            File artifactFile = new File(artifactDir, artifactName);
            if (artifactFile.exists()) {
                displayChecksumsForFile(artifactDir, artifactName);
            }
        }
    }

    /**
     * Displays checksums for a single file.
     * 
     * @param artifactDir  The directory containing the artifact
     * @param artifactName The name of the artifact file
     * @throws MojoFailureException if reading checksums fails
     */
    private void displayChecksumsForFile(File artifactDir, String artifactName) throws MojoFailureException {
        StringBuilder checksumInfo = new StringBuilder("  " + artifactName);
        boolean hasChecksums = false;

        // Define checksum types with their extensions and labels
        List<ChecksumType> checksumTypes = new ArrayList<>();
        checksumTypes.add(new ChecksumType("MD5", MD5_EXTENSION, true));
        checksumTypes.add(new ChecksumType("SHA-1", SHA1_EXTENSION, true));
        checksumTypes.add(new ChecksumType("SHA-256", SHA256_EXTENSION, this.generateChecksums256));
        checksumTypes.add(new ChecksumType("SHA-512", SHA512_EXTENSION, this.generateChecksums512));

        // Iterate through all checksum types
        for (ChecksumType checksumType : checksumTypes) {
            if (checksumType.enabled) {
                File checksumFile = new File(artifactDir, artifactName + checksumType.extension);
                if (checksumFile.exists()) {
                    try {
                        String checksum = new String(Files.readAllBytes(checksumFile.toPath())).trim();
                        checksumInfo.append("\n    ").append(checksumType.label).append(": ").append(checksum);
                        hasChecksums = true;
                    } catch (IOException e) {
                        throw new MojoFailureException("Failed to read " + checksumType.label + " checksum for " + artifactName, e);
                    }
                }
            }
        }

        if (hasChecksums) {
            getLog().info(checksumInfo.toString());
        }
    }

    /**
     * Helper class to represent a checksum type with its properties.
     */
    private static class ChecksumType {
        final String label;
        final String extension;
        final boolean enabled;

        ChecksumType(String label, String extension, boolean enabled) {
            this.label = label;
            this.extension = extension;
            this.enabled = enabled;
        }
    }

    /**
     * Ensures that all downloaded artifacts have MD5 and SHA1 checksum files.
     * Generates missing checksum files for each artifact.
     * 
     * @param stagingDir     The staging directory containing downloaded artifacts
     * @param targetProjects List of Maven projects to process
     * @throws MojoFailureException if checksum generation fails
     */
    private void ensureDownloadedArtifactsChecksums(File stagingDir, List<MavenProject> targetProjects)
            throws MojoFailureException {
        if (this.dryRun) {
            logDryRunChecksums(targetProjects);
            return;
        }

        getLog().info("Checking and generating checksums for downloaded artifacts if needed...");

        for (MavenProject targetProject : targetProjects) {
            String groupId = targetProject.getGroupId();
            String artifactId = targetProject.getArtifactId();
            String projectVersion = targetProject.getVersion();

            // Build path to downloaded artifacts
            String groupPath = groupId.replace('.', '/');
            File artifactDir = new File(new File(new File(stagingDir, groupPath), artifactId), projectVersion);

            if (artifactDir.exists()) {
                if (this.forceGenerateChecksums) {
                    getLog().info("Force regenerating all checksums for downloaded artifacts: " + groupId + ":"
                            + artifactId + ":"
                            + projectVersion);
                    generateMissingChecksums(artifactDir, artifactId, projectVersion, targetProject.getPackaging(),
                            true);
                } else {
                    generateMissingChecksums(artifactDir, artifactId, projectVersion, targetProject.getPackaging(),
                            false);
                }
            } else {
                getLog().warn("Artifact directory not found for checksum generation: " + artifactDir.getAbsolutePath());
            }
        }
    }

    /**
     * Generates missing MD5 and SHA1 checksum files for artifacts in a directory.
     * 
     * @param artifactDir     The directory containing the artifacts
     * @param artifactId      The artifact ID
     * @param version         The version of the artifact
     * @param forceRegenerate If true, regenerate checksums even if they already
     *                        exist
     * @throws MojoFailureException if checksum generation fails
     */
    private void generateMissingChecksums(File artifactDir, String artifactId, String version, String packaging,
            boolean forceRegenerate)
            throws MojoFailureException {
        for (String artifactName : buildArtifactFileNames(artifactId, version, packaging)) {
            File artifactFile = new File(artifactDir, artifactName);
            if (artifactFile.exists()) {
                // Always generate MD5 and SHA-1 checksums when generateChecksums is enabled
                generateChecksumForArtifact(artifactDir, artifactFile, artifactName, "MD5", MD5_EXTENSION,
                        forceRegenerate);
                generateChecksumForArtifact(artifactDir, artifactFile, artifactName, "SHA-1", SHA1_EXTENSION,
                        forceRegenerate);

                // Generate SHA-256 checksums if enabled
                if (this.generateChecksums256) {
                    generateChecksumForArtifact(artifactDir, artifactFile, artifactName, "SHA-256", SHA256_EXTENSION,
                            forceRegenerate);
                }

                // Generate SHA-512 checksums if enabled
                if (this.generateChecksums512) {
                    generateChecksumForArtifact(artifactDir, artifactFile, artifactName, "SHA-512", SHA512_EXTENSION,
                            forceRegenerate);
                }
            }
        }
    }

    /**
     * Generates a single checksum file for an artifact if missing or if force
     * regeneration is requested.
     * 
     * @param artifactDir     The directory containing the artifacts
     * @param artifactFile    The artifact file to generate checksum for
     * @param artifactName    The name of the artifact for logging
     * @param algorithm       The hash algorithm (MD5, SHA-1, etc.)
     * @param extension       The file extension for the checksum file (.md5, .sha1,
     *                        etc.)
     * @param forceRegenerate If true, regenerate checksum even if it already exists
     * @throws MojoFailureException if checksum generation fails
     */
    private void generateChecksumForArtifact(File artifactDir, File artifactFile, String artifactName,
            String algorithm, String extension, boolean forceRegenerate) throws MojoFailureException {
        try {
            File checksumFile = new File(artifactDir, artifactName + extension);
            if (forceRegenerate || !checksumFile.exists()) {
                String hash = calculateHashWithCommonsCodec(artifactFile, algorithm);
                java.nio.file.Files.write(checksumFile.toPath(), hash.getBytes());

                String action = forceRegenerate ? "Force regenerated" : "Generated";
                String algorithmName = algorithm.replace("-", "");
                getLog().info(action + " " + algorithmName + " checksum for: " + artifactName + extension);
            }
        } catch (Exception e) {
            throw new MojoFailureException("Failed to generate " + algorithm + " checksum for " + artifactName, e);
        }
    }

    /**
     * Calculates a hash digest for a file using Apache Commons Codec.
     * 
     * @param file      The file to calculate hash for
     * @param algorithm The hash algorithm (MD5, SHA-1, SHA-256, SHA-512)
     * @return The hexadecimal representation of the hash
     * @throws java.io.IOException if file reading fails
     */
    private String calculateHashWithCommonsCodec(File file, String algorithm) throws java.io.IOException {
        try (java.io.FileInputStream fis = new java.io.FileInputStream(file)) {
            return switch (algorithm) {
                case "MD5" -> DigestUtils.md5Hex(fis);
                case "SHA-1" -> DigestUtils.sha1Hex(fis);
                case "SHA-256" -> DigestUtils.sha256Hex(fis);
                case "SHA-512" -> DigestUtils.sha512Hex(fis);
                default -> throw new IllegalArgumentException("Unsupported hash algorithm: " + algorithm);
            };
        }
    }

    /**
     * Ensures that all downloaded artifacts are signed with GPG signatures.
     * Checks for missing .asc files and generates them if needed.
     * 
     * @param stagingDir     The staging directory containing downloaded artifacts
     * @param targetProjects List of Maven projects to process
     * @throws MojoFailureException if signing fails
     */
    private void ensureDownloadedArtifactsSigned(File stagingDir, List<MavenProject> targetProjects)
            throws MojoFailureException {
        if (this.dryRun) {
            logDryRunSigning(targetProjects);
            return;
        }

        getLog().info("Checking and signing downloaded artifacts if needed...");

        for (MavenProject targetProject : targetProjects) {
            String groupId = targetProject.getGroupId();
            String artifactId = targetProject.getArtifactId();
            String projectVersion = targetProject.getVersion();

            String groupPath = groupId.replace('.', '/');
            File artifactDir = new File(new File(new File(stagingDir, groupPath), artifactId), projectVersion);

            if (artifactDir.exists()) {
                if (this.forceSignArtifacts) {
                    getLog().info("Force resigning all downloaded artifacts for " + groupId + ":" + artifactId + ":"
                            + projectVersion);
                    signDownloadedArtifacts(artifactDir, artifactId, projectVersion, targetProject, true);
                } else if (downloadedArtifactsNeedSigning(artifactDir, artifactId, projectVersion,
                        targetProject.getPackaging())) {
                    getLog().info(
                            "Signing downloaded artifacts for " + groupId + ":" + artifactId + ":" + projectVersion);
                    signDownloadedArtifacts(artifactDir, artifactId, projectVersion, targetProject, false);
                } else {
                    getLog().debug("All signatures present for downloaded artifacts: " + groupId + ":" + artifactId
                            + ":" + projectVersion);
                }
            } else {
                getLog().warn("Artifact directory not found for signing: " + artifactDir.getAbsolutePath());
            }
        }
    }

    /**
     * Logs checksum generation operations in dry-run mode.
     */
    private void logDryRunChecksums(List<MavenProject> targetProjects) {
        getLog().info("DRY-RUN: Would check and generate checksums for downloaded artifacts if needed...");
        for (MavenProject targetProject : targetProjects) {
            String gav = targetProject.getGroupId() + ":" + targetProject.getArtifactId() + ":"
                    + targetProject.getVersion();
            getLog().info("DRY-RUN:   - Generate MD5/SHA1 checksums for " + gav + " artifacts");
        }
    }

    /**
     * Logs signing operations in dry-run mode.
     */
    private void logDryRunSigning(List<MavenProject> targetProjects) {
        getLog().info("DRY-RUN: Would check and sign downloaded artifacts if needed...");
        for (MavenProject targetProject : targetProjects) {
            if (targetProject == null || POM_PACKAGING.equals(targetProject.getPackaging())) {
                continue;
            }
            String gav = targetProject.getGroupId() + ":" + targetProject.getArtifactId() + ":"
                    + targetProject.getVersion();
            String packaging = targetProject.getPackaging();
            if (isEclipsePackaging(packaging)) {
                getLog().info("DRY-RUN:   - Sign " + packaging + " artifacts for " + gav + " using maven-gpg-plugin");
            } else {
                getLog().info("DRY-RUN:   - Sign artifacts for " + gav + " using maven-gpg-plugin");
            }
        }
    }

    /**
     * Signs downloaded artifacts using the GPG plugin.
     * 
     * @param artifactDir   The directory containing the artifacts
     * @param artifactId    The artifact ID
     * @param version       The version of the artifact
     * @param targetProject The Maven project for configuration
     * @param forceResign   Whether to force resigning existing signatures
     * @throws MojoFailureException if signing fails
     */
    private void signDownloadedArtifacts(File artifactDir, String artifactId, String version,
            MavenProject targetProject, boolean forceResign) throws MojoFailureException {
        try {
            String packaging = targetProject.getPackaging();
            for (String artifactName : buildArtifactFileNames(artifactId, version, packaging)) {
                File artifactFile = new File(artifactDir, artifactName);
                File ascFile = new File(artifactDir, artifactName + ASC_EXTENSION);
                if (artifactFile.exists() && (forceResign || !ascFile.exists())) {
                    signSingleArtifact(artifactFile, ascFile, artifactName);
                }else {
                    getLog().info("Signature already present for: " + artifactName);
                }
            }
        } catch (Exception e) {
            throw new MojoFailureException("Failed to sign downloaded artifacts for " + targetProject.getArtifactId(),
                    e);
        }
    }

    /**
     * Signs a single artifact file using the GPG plugin via Maven Invoker API.
     * 
     * @param artifactFile  The file to sign
     * @param signatureFile The signature file to create
     * @param artifactName  The name of the artifact for logging
     * @throws MojoFailureException if signing fails
     */
    private void signSingleArtifact(File artifactFile, File signatureFile, String artifactName)
            throws MojoFailureException {
        getLog().info("Start Signing artifact: " + artifactName);

        // Extract GAV information from the artifact name and directory structure
        String[] gavInfo = extractGAVFromArtifactContext(artifactFile, artifactName);
        String groupId = gavInfo[0];
        String artifactId = gavInfo[1];
        String version = gavInfo[2];
        String packaging = gavInfo[3];
        String classifier = gavInfo[4]; // may be null

        // Set up properties for the GPG sign-and-deploy-file goal
        java.util.Properties properties = new java.util.Properties();
        properties.setProperty("file", artifactFile.getAbsolutePath());
        properties.setProperty("generatePom", FALSE);

        // Required GAV properties
        properties.setProperty("groupId", groupId);
        properties.setProperty("artifactId", artifactId);
        properties.setProperty("version", version);
        properties.setProperty("packaging", packaging);

        // Add classifier if present
        if (classifier != null && !classifier.isEmpty()) {
            properties.setProperty("classifier", classifier);
        }

        // We only want to sign, not deploy, so we set a dummy repository URL
        properties.setProperty("repositoryId", "dummy");
        properties.setProperty("url", "file:///tmp/dummy-repo");

        // Use the inherited executeMavenGoal method
        getLog().info("Signing artifact using maven-gpg-plugin:sign-and-deploy-file - " + artifactName);
        boolean signSucceeded = executeMavenGoal("org.apache.maven.plugins:maven-gpg-plugin:sign-and-deploy-file",
                properties, packaging, artifactName);

        if (signSucceeded) {
            // The sign-and-deploy-file goal creates the .asc file next to the original file
            File expectedSignatureFile = new File(artifactFile.getAbsolutePath() + ASC_EXTENSION);
            if (expectedSignatureFile.exists()) {
                // If we specified a different signature file location, move it
                if (!expectedSignatureFile.equals(signatureFile)) {
                    try {
                        Files.move(expectedSignatureFile.toPath(), signatureFile.toPath(),
                                java.nio.file.StandardCopyOption.REPLACE_EXISTING);
                    } catch (IOException e) {
                        getLog().warn("Could not move signature file from " + expectedSignatureFile + " to "
                                + signatureFile + ": " + e.getMessage());
                    }
                }
                getLog().info("Signed artifact: " + artifactName + " -> " + signatureFile.getName());
            } else {
                getLog().warn("Signature file was not created for: " + artifactName);
            }
        } else {
            throw new MojoFailureException("Failed to sign artifact: " + artifactName);
        }
    }

    /**
     * Extracts GAV (Group-Artifact-Version) information from the artifact file
     * context.
     * 
     * @param artifactFile The artifact file
     * @param artifactName The artifact filename
     * @return Array containing [groupId, artifactId, version, packaging,
     *         classifier]
     */
    private String[] extractGAVFromArtifactContext(File artifactFile, String artifactName) {
        // The staging directory structure is:
        // staging/groupId/artifactId/version/filename
        // We need to traverse up the directory structure to extract GAV info

        File versionDir = artifactFile.getParentFile();
        File artifactIdDir = versionDir.getParentFile();
        File groupIdDir = artifactIdDir.getParentFile();

        String version = versionDir.getName();
        String artifactId = artifactIdDir.getName();

        // Reconstruct groupId from the path (it may have been converted from dots to
        // slashes)
        String groupId = reconstructGroupId(groupIdDir);

        // Extract packaging and classifier from filename
        String[] packagingInfo = extractPackagingAndClassifier(artifactName, artifactId, version);
        String packaging = packagingInfo[0];
        String classifier = packagingInfo[1]; // may be null

        return new String[] { groupId, artifactId, version, packaging, classifier };
    }

    /**
     * Reconstructs the groupId from the directory structure.
     * 
     * @param groupIdDir   The directory representing the groupId structure
     * @param artifactFile The artifact file for reference
     * @return The reconstructed groupId
     */
    private String reconstructGroupId(File groupIdDir) {
        // Find the staging directory root to calculate the relative path
        File currentDir = groupIdDir;
        StringBuilder groupIdBuilder = new StringBuilder();

        // We need to find where the staging directory ends
        // The staging directory structure is: staging/groupId/artifactId/version
        // So we go up until we find a directory that looks like staging
        while (currentDir != null && !currentDir.getName().equals(this.syncStagingDirName)) {
            if (!groupIdBuilder.isEmpty()) {
                groupIdBuilder.insert(0, ".");
            }
            groupIdBuilder.insert(0, currentDir.getName());
            currentDir = currentDir.getParentFile();
        }

        return groupIdBuilder.toString();
    }

    /**
     * Extracts packaging type and classifier from the artifact filename.
     * 
     * @param artifactName The artifact filename
     * @param artifactId   The artifact ID
     * @param version      The version
     * @return Array containing [packaging, classifier] where classifier may be null
     */
    private String[] extractPackagingAndClassifier(String artifactName, String artifactId, String version) {
        String baseName = artifactId + "-" + version;

        // Remove the base name to get the suffix
        String suffix = artifactName.substring(baseName.length());

        // Check for common patterns
        if (suffix.equals(POM_EXTENSION)) {
            return new String[] { "pom", null };
        } else if (suffix.equals(JAR_EXTENSION)) {
            return new String[] { "jar", null };
        } else if (suffix.equals(ZIP_EXTENSION)) {
            return new String[] { "zip", null };
        } else if (suffix.equals(SOURCES_JAR_SUFFIX)) {
            return new String[] { "jar", "sources" };
        } else if (suffix.equals(JAVADOC_JAR_SUFFIX)) {
            return new String[] { "jar", "javadoc" };
        } else if (suffix.endsWith(".xml")) {
            // P2 metadata files
            if (suffix.equals(P2_ARTIFACTS_SUFFIX)) {
                return new String[] { "xml", "p2artifacts" };
            } else if (suffix.equals(P2_METADATA_SUFFIX)) {
                return new String[] { "xml", "p2metadata" };
            }
            return new String[] { "xml", null };
        }

        // Default fallback - try to extract from file extension
        int lastDot = suffix.lastIndexOf('.');
        if (lastDot > 0) {
            String extension = suffix.substring(lastDot + 1);
            String beforeExtension = suffix.substring(0, lastDot);

            // Check if there's a classifier before the extension
            if (beforeExtension.startsWith("-")) {
                String classifier = beforeExtension.substring(1);
                return new String[] { extension, classifier };
            } else {
                return new String[] { extension, null };
            }
        }

        // Final fallback
        return new String[] { "jar", null };
    }

    /**
     * Builds the list of artifact filenames for a given artifactId and version.
     * 
     * @param artifactId The artifact ID
     * @param version    The version of the artifact
     * @param packaging  The packaging type of the artifact (jar, pom,
     *                   eclipse-repository, etc.)
     * @return List of artifact filenames
     */
    private List<String> buildArtifactFileNames(String artifactId, String version, String packaging) {
        List<String> names = new ArrayList<>();
        String baseName = artifactId + "-" + version;

        // Always include POM
        names.add(baseName + POM_EXTENSION);

        // Include main artifact based on packaging type
        if (ECLIPSE_REPOSITORY_PACKAGING.equals(packaging)) {
            // Eclipse repository produces ZIP artifacts
            names.add(baseName + ZIP_EXTENSION);
        } else if (!POM_PACKAGING.equals(packaging)) {
            // Standard JAR packaging (includes eclipse-feature and eclipse-plugin)
            names.add(baseName + JAR_EXTENSION);
        }

        // Eclipse repository packaging typically doesn't have separate sources/javadoc
        // but include the filenames anyway for completeness
        if (!ECLIPSE_REPOSITORY_PACKAGING.equals(packaging)) {
            names.add(baseName + SOURCES_JAR_SUFFIX);
            names.add(baseName + JAVADOC_JAR_SUFFIX);
        }

        // Include P2 metadata for Eclipse packagings or when explicitly requested
        if (this.p2Metadata || isEclipsePackaging(packaging)) {
            names.add(baseName + P2_ARTIFACTS_SUFFIX);
            names.add(baseName + P2_METADATA_SUFFIX);
        }
        return names;
    }

    /**
     * Checks if downloaded artifacts need GPG signing by looking for missing .asc
     * files.
     * 
     * @param artifactDir The directory containing the artifacts
     * @param artifactId  The artifact ID
     * @param version     The version of the artifact
     * @param packaging   The packaging type of the artifact
     * @return true if any artifacts are missing signatures, false otherwise
     */
    private boolean downloadedArtifactsNeedSigning(File artifactDir, String artifactId, String version,
            String packaging) {
        for (String artifactName : buildArtifactFileNames(artifactId, version, packaging)) {
            File artifactFile = new File(artifactDir, artifactName);
            if (artifactFile.exists()) {
                File ascFile = new File(artifactDir, artifactName + ASC_EXTENSION);
                if (!ascFile.exists()) {
                    return true;
                }
            }
        }
        return false;
    }

    // ================================================================================================
    // RC-DOWNLOAD INVOCATION
    // ================================================================================================

    /**
     * Executes the rc-download goal to download artifacts first by calling
     * RcDownloadMojo directly.
     * 
     * @throws MojoFailureException if rc-download execution fails
     */
    private void executeRcDownload() throws MojoFailureException {
        if (this.skipDownload) {
            getLog().info("Skipping download phase: central.skipDownload=true");
            return;
        }

        getLog().info("Creating and configuring RcDownloadMojo instance...");

        // Create an instance of RcDownloadMojo
        RcDownloadMojo downloadMojo = new RcDownloadMojo();

        // Map all the properties from this mojo to the download mojo
        mapPropertiesToDownloadMojo(downloadMojo);

        try {
            // Execute the download mojo directly
            downloadMojo.execute();
            getLog().info("RcDownloadMojo executed successfully");
        } catch (Exception e) {
            throw new MojoFailureException("Failed to execute RcDownloadMojo", e);
        }
    }

    /**
     * Maps properties from this bundle mojo to the download mojo.
     * 
     * @param downloadMojo The RcDownloadMojo instance to configure
     */
    private void mapPropertiesToDownloadMojo(RcDownloadMojo downloadMojo) {
        // Repository configuration
        downloadMojo.serverSyncId = this.serverSyncId;
        downloadMojo.repositoryUrl = this.repositoryUrl;
        downloadMojo.repositoryLayout = this.repositoryLayout;

        // GAV configuration
        downloadMojo.namespace = this.namespace;
        downloadMojo.name = this.name;
        downloadMojo.version = this.version;

        // File and Directory configuration
        downloadMojo.syncStagingDirName = this.syncStagingDirName;
        downloadMojo.syncStagingDir = this.syncStagingDir;
        downloadMojo.syncBundleFile = this.syncBundleFile;

        // Execution Mode configuration
        downloadMojo.dryRun = this.dryRun;
        downloadMojo.skipDownload = this.skipDownload;

        // P2 and output configuration
        downloadMojo.p2Metadata = this.p2Metadata;
        downloadMojo.showMavenGoalOutput = this.showMavenGoalOutput;

        // Failure handling configuration
        downloadMojo.failOnMissingSourcesJavadoc = this.failOnMissingSourcesJavadoc;
        downloadMojo.failOnMissingSignatureFile = this.failOnMissingSignatureFile;
        downloadMojo.failOnMissingChecksum = this.failOnMissingChecksum;

        // Download configuration - enable all downloads, let bundle mojo handle
        // processing
        downloadMojo.downloadSignatures = this.downloadSignatures;
        downloadMojo.downloadChecksums = this.downloadChecksums;
        downloadMojo.downloadChecksums256 = this.downloadChecksums256;
        downloadMojo.downloadChecksums512 = this.downloadChecksums512;

        // Inject Maven components
        downloadMojo.reactorProjects = this.reactorProjects;
        downloadMojo.session = this.session;
        downloadMojo.invoker = this.invoker;
        downloadMojo.mojoExecution = this.mojoExecution;
        downloadMojo.repositorySystem = this.repositorySystem;

        // Set project if available (from AbstractCentralMojo)
        if (this.project != null) {
            downloadMojo.project = this.project;
        }
    }

    // ================================================================================================
    // UTILITY METHODS
    // ================================================================================================
    /**
     * Displays the current configuration and GAV coordinates to be downloaded.
     * 
     * @param gav The GAV (Group:Artifact:Version) array to display
     */
    private void showConfig(String[] gav) {
        getLog().info("GAV to download: " + String.join(":", gav));
        getLog().info(
                "Config: \n" +
                        "  ============== Remote Repository Configuration ===============\n" +
                        "         central.serverSyncId=" + this.serverSyncId + "\n" +
                        "         central.repositoryUrl=" + this.repositoryUrl + "\n" +
                        "         central.repositoryLayout=" + this.repositoryLayout + "\n" +
                        "  =============== GAV Configuration ===============\n" +
                        "         central.namespace=" + (this.namespace != null ? this.namespace : "default") + "\n" +
                        "         central.name=" + (this.name != null ? this.name : "default") + "\n" +
                        "         central.version=" + (this.version != null ? this.version : "default") + "\n" +
                        "  =============== File and Directory Configuration ===============\n" +
                        "         central.syncStagingDir="
                        + (this.syncStagingDir != null ? this.syncStagingDir : "default") + "\n" +
                        "         central.syncStagingDirName="
                        + (this.syncStagingDirName != null ? this.syncStagingDirName : "default") + "\n" +
                        "         central.syncBundleFile="
                        + (this.syncBundleFile != null ? this.syncBundleFile.getAbsolutePath() : "default") + "\n" +
                        "  =============== Execution Mode Configuration ===============\n" +
                        "         central.dryRun=" + this.dryRun + "\n" +
                        "         central.skipDownload=" + this.skipDownload + "\n" +
                        "         central.zipArtifacts=" + this.zipArtifacts + "\n" +
                        "  =============== Output Configuration ===============\n" +
                        "         central.showMavenGoalOutput=" + this.showMavenGoalOutput + "\n" +
                        "  =============== Failure Handling Configuration ===============\n" +
                        "         central.failOnMissingSourcesJavadoc=" + this.failOnMissingSourcesJavadoc + "\n" +
                        "         central.failOnMissingSignatureFile=" + this.failOnMissingSignatureFile + "\n" +
                        "         central.failOnMissingChecksum=" + this.failOnMissingChecksum + "\n" +
                        "  =============== Artifact Processing Configuration ===============\n" +
                        "         central.generateChecksums=" + this.generateChecksums + "\n" +
                        "         central.forceGenerateChecksums=" + this.forceGenerateChecksums + "\n" +
                        "         central.generateChecksums256=" + this.generateChecksums256 + "\n" +
                        "         central.generateChecksums512=" + this.generateChecksums512 + "\n" +
                        "         central.signArtifacts=" + this.signArtifacts + "\n" +
                        "         central.forceSignArtifacts=" + this.forceSignArtifacts + "\n" +
                        "         central.p2Metadata=" + this.p2Metadata);
    }

    /**
     * Creates a ZIP archive from the contents of the staging directory.
     * 
     * This method recursively walks through all files in the staging directory
     * and packages them into a ZIP file suitable for upload to Maven Central.
     * Directory structure is preserved in the ZIP using forward slashes as
     * separators.
     * 
     * @param stagingDir The directory containing files to zip
     * @param outZip     The output zip file
     * @return The created zip file
     * @throws IOException if zipping fails
     */
    private File zipStaging(File stagingDir, File outZip) throws IOException {
        Path root = stagingDir.toPath();
        Files.createDirectories(outZip.toPath().getParent());
        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(outZip.toPath()));
                java.util.stream.Stream<Path> stream = Files.walk(root)) {
            stream.filter(p -> p.toFile().isFile())
                    .forEach(p -> {
                        String entryName = root.relativize(p).toString().replace('\\', '/');
                        try {
                            zos.putNextEntry(new ZipEntry(entryName));
                            Files.copy(p, zos);
                            zos.closeEntry();
                        } catch (IOException e) {
                            throw new java.io.UncheckedIOException(e);
                        }
                    });
        } catch (java.io.UncheckedIOException e) {
            throw e.getCause();
        }
        getLog().info("Bundle ZIP created from staging: " + outZip.getAbsolutePath());
        return outZip;
    }


    // ================================================================================================
    // DRY-RUN LOGGING METHODS
    // ================================================================================================

    private void logPostProcessing(boolean generateChecksums, boolean signArtifacts, boolean zipArtifacts) {
        if (generateChecksums) {
            getLog().info("DRY-RUN: Would create checksums for downloaded artifacts");
        } else {
            getLog().info("DRY-RUN: Would skip checksum creation (central.generateChecksums=false)");
        }

        if (signArtifacts) {
            getLog().info("DRY-RUN: Would create signatures for downloaded artifacts");
        } else {
            getLog().info("DRY-RUN: Would skip signature creation (central.signArtifacts=false)");
        }

        if (zipArtifacts) {
            getLog().info("DRY-RUN: Would create ZIP bundle from staging directory");
        } else {
            getLog().info("DRY-RUN: Would skip ZIP bundle creation (central.zipArtifacts=false)");
        }
    }
}
