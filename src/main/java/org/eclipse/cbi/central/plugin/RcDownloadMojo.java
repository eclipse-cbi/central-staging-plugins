/*
 * Copyright (c) 2025 Eclipse Foundation and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * // Some portions generated by Co-Pilot
 */

package org.eclipse.cbi.central.plugin;

import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugin.MojoFailureException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.List;
import java.util.Collections;

import org.apache.maven.project.MavenProject;
import org.apache.maven.model.Model;
import org.apache.maven.model.Repository;

import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.repository.Authentication;
import org.eclipse.aether.util.repository.AuthenticationBuilder;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.ArtifactResolutionException;

@Mojo(name = "rc-download", defaultPhase = LifecyclePhase.NONE, requiresProject = true)
public class RcDownloadMojo extends AbstractStagingMojo {

    /** Default repository layout */
    private static final String DEFAULT_LAYOUT = "default";

    /**
     * Maven Artifact Resolver system for downloading artifacts.
     * Injected by Maven.
     */
    @Component
    protected RepositorySystem repositorySystem;

    /**
     * Cache of artifacts that failed to download during artifact resolution.
     */
    private final java.util.Set<String> failedDownloads = new java.util.HashSet<>();

    /**
     * Cache of mandatory artifacts that failed to download.
     */
    private final java.util.Set<String> failedMandatoryDownloads = new java.util.HashSet<>();

    /**
     * Main execution method for the rc-download Maven goal.
     * 
     * Downloads artifacts from a remote repository to a staging directory.
     * 
     * @throws MojoFailureException if any step in the download process fails
     */
    @Override
    public void execute() throws MojoFailureException {
        getLog().info("Starting rc-download goal");

        // Verify that repositorySystem was injected properly
        if (this.repositorySystem == null) {
            throw new MojoFailureException(
                    "Maven RepositorySystem was not injected. This can happen when:\n" +
                            "  1. The plugin is executed outside of a Maven project context\n" +
                            "  2. The Maven version is incompatible\n" +
                            "  3. There's a classloading issue\n" +
                            "Please ensure you're running this goal within a valid Maven project.");
        }

        if (this.skipDownload) {
            getLog().info("Skipping rc-download: central.skipDownload=true");
            return;
        }

        // Display Maven execution context information
        logMavenExecutionContext();

        // Check if we have explicit GAV parameters
        boolean hasExplicitGav = this.namespace != null && !this.namespace.isBlank()
                && this.name != null && !this.name.isBlank()
                && this.version != null && !this.version.isBlank();

        // Only check execution root if we don't have explicit GAV
        if (!hasExplicitGav && this.project != null && !this.project.isExecutionRoot()) {
            getLog().info("Skipping rc-download: not execution root");
            return;
        }

        String[] gav = resolveEffectiveGav();
        showConfig(gav);

        List<MavenProject> targetProjects = this.resolveTargetProjects();

        logDryRunStart();

        downloadFromRemote(targetProjects);

        logDryRunSummary();

        getLog().info("Download completed successfully.");
    }

    // ================================================================================================
    // DOWNLOAD METHODS
    // ================================================================================================

    /**
     * Downloads artifacts from a remote repository to staging directory.
     * 
     * @param targetProjects List of Maven projects to process
     * @throws MojoFailureException if the download fails
     */
    public void downloadFromRemote(List<MavenProject> targetProjects) throws MojoFailureException {
        Repository repo = requireRemoteRepository(this.serverSyncId);
        File stagingDir = new File(prepareStagingDirectory());
        if (!stagingDir.exists() && !stagingDir.mkdirs()) {
            throw new MojoFailureException("Failed to create staging directory: " + stagingDir);
        }

        try {
            // For each target project, download its artifacts via dependency:get
            for (MavenProject targetProject : targetProjects) {
                String g = targetProject.getGroupId();
                String a = targetProject.getArtifactId();
                String v = targetProject.getVersion();

                getLog().info("Downloading artifacts for " + g + ":" + a + ":" + v);
                // Download the artifacts
                downloadArtifacts(repo, targetProject, stagingDir);
            }

            if (this.dryRun) {
                getLog().info("DRY-RUN: Download simulation completed");
            }

            getLog().info("Artifacts downloaded to staging directory: " + stagingDir.getAbsolutePath());

        } catch (Exception e) {
            throw new MojoFailureException("Failed to download artifacts", e);
        }
    }

    // ================================================================================================
    // REPOSITORY AND CONFIGURATION METHODS
    // ================================================================================================

    /**
     * Creates a Repository object using the provided server ID and repository URL.
     * 
     * This method sets up the remote repository configuration for artifact
     * downloads,
     * including authentication settings via the server ID.
     * 
     * @param serverId The server ID for authentication in settings.xml
     * @return A Repository object configured with the server ID and repository URL
     */
    private Repository requireRemoteRepository(String serverId) {
        // Create repository using the provided URL and serverId for authentication
        Repository repo = new Repository();
        if (serverId != null && !serverId.isEmpty()) {
            repo.setId(serverId);
        }
        repo.setUrl(this.repositoryUrl);
        repo.setLayout(this.repositoryLayout);
        repo.setName("Remote Repository for Download");
        return repo;
    }

    // ================================================================================================
    // ARTIFACT DOWNLOAD METHODS
    // ================================================================================================

    /**
     * Context object for artifact download operations to reduce parameter count.
     */
    private static class ArtifactDownloadContext {
        final RemoteRepository remoteRepo;
        final String groupId;
        final String artifactId;
        final String version;
        final String extension;
        final String classifier;
        final File targetDir;
        final boolean isMandatory;

        ArtifactDownloadContext(RemoteRepository remoteRepo, String groupId, String artifactId,
                String version, String extension, String classifier, File targetDir, boolean isMandatory) {
            this.remoteRepo = remoteRepo;
            this.groupId = groupId;
            this.artifactId = artifactId;
            this.version = version;
            this.extension = extension;
            this.classifier = classifier;
            this.targetDir = targetDir;
            this.isMandatory = isMandatory;
        }
    }

    /**
     * Creates a RemoteRepository from the Maven Repository configuration with
     * authentication.
     * 
     * @param repo The Maven repository configuration
     * @return A configured RemoteRepository for Aether
     */
    private RemoteRepository createRemoteRepository(Repository repo) {
        RemoteRepository.Builder builder = new RemoteRepository.Builder(
                repo.getId(),
                repo.getLayout() != null ? repo.getLayout() : DEFAULT_LAYOUT,
                repo.getUrl());

        // Add authentication if server ID is configured
        if (repo.getId() != null && !repo.getId().isEmpty()) {
            org.apache.maven.settings.Server server = null;
            if (this.settings != null) {
                server = this.settings.getServer(repo.getId());
            }

            if (server != null) {
                Authentication auth = new AuthenticationBuilder()
                        .addUsername(server.getUsername())
                        .addPassword(server.getPassword())
                        .build();
                builder.setAuthentication(auth);
                getLog().debug("Authentication configured for repository: " + repo.getId());
            }
        }

        return builder.build();
    }

    /**
     * Downloads an artifact using Maven Artifact Resolver directly.
     * 
     * @param remoteRepo The remote repository to download from
     * @param groupId    The group ID of the artifact
     * @param artifactId The artifact ID
     * @param version    The version of the artifact
     * @param extension  The file extension (jar, pom, xml, etc.)
     * @param classifier The classifier (sources, javadoc, p2artifacts, etc.) or
     *                   null
     * @param targetDir  The target directory to copy the artifact to
     * @return true if successful, false if failed
     */
    private boolean downloadArtifactWithResolver(RemoteRepository remoteRepo, String groupId, String artifactId,
            String version, String extension, String classifier, File targetDir) {

        String coords = groupId + ":" + artifactId + ":" + extension + ":" + version;
        if (classifier != null && !classifier.isEmpty()) {
            coords = groupId + ":" + artifactId + ":" + extension + ":" + classifier + ":" + version;
        }

        try {
            // Create the artifact descriptor
            Artifact artifact = new DefaultArtifact(coords);

            getLog().debug("Resolving artifact: " + artifact);

            // Create the artifact request
            ArtifactRequest request = new ArtifactRequest();
            request.setArtifact(artifact);
            request.setRepositories(Collections.singletonList(remoteRepo));

            // Get the repository system session from Maven session
            // Create a new session without WorkspaceReader to force resolution from local
            // cache only
            RepositorySystemSession repositorySession = this.session.getRepositorySession();
            DefaultRepositorySystemSession localCacheSession = new DefaultRepositorySystemSession(repositorySession);
            // Remove WorkspaceReader to prevent resolution from reactor projects
            localCacheSession.setWorkspaceReader(null);

            // Resolve the artifact using the modified session
            ArtifactResult result = repositorySystem.resolveArtifact(localCacheSession, request);

            if (result.isResolved()) {
                File resolvedFile = result.getArtifact().getFile();

                // Build the target filename
                String targetFileName = artifactId + "-" + version;
                if (classifier != null && !classifier.isEmpty()) {
                    targetFileName += "-" + classifier;
                }
                targetFileName += "." + extension;

                File targetFile = new File(targetDir, targetFileName);

                // Copy the file to the staging directory
                if (!targetDir.exists()) {
                    targetDir.mkdirs();
                }
                getLog().info("Copying resolved artifact From " + resolvedFile.getAbsolutePath() + " to: "
                        + targetFile.getAbsolutePath());
                Files.copy(resolvedFile.toPath(), targetFile.toPath(),
                        java.nio.file.StandardCopyOption.REPLACE_EXISTING);

                getLog().info("Successfully resolved and copied: " + coords + " -> " + targetFileName);
                return true;
            } else {
                getLog().warn("Artifact not resolved: " + coords);
                return false;
            }

        } catch (ArtifactResolutionException e) {
            getLog().debug("Failed to resolve artifact: " + coords + " - " + e.getMessage());
            return false;
        } catch (IOException e) {
            getLog().error("Failed to copy artifact: " + coords + " - " + e.getMessage());
            return false;
        }
    }

    /**
     * Downloads artifacts using Maven Artifact Resolver API directly.
     * 
     * This method replaces the two-step dependency:get + dependency:copy approach
     * with direct artifact resolution using Maven Artifact Resolver.
     * 
     * Supports downloading main JAR, POM, sources, Javadoc, and optionally P2
     * metadata files.
     * In dry-run mode, only logs planned operations without executing them.
     * 
     * @param repo       The repository to download from
     * @param project    The Maven project containing GAV and packaging information
     * @param stagingDir The staging directory to download to
     * @throws MojoFailureException if the download fails
     */
    private void downloadArtifacts(Repository repo, MavenProject project, File stagingDir) throws MojoFailureException {
        String groupId = project.getGroupId();
        String artifactId = project.getArtifactId();
        String projectVersion = project.getVersion();
        String packaging = project.getPackaging();
        String gav = groupId + ":" + artifactId + ":" + projectVersion;

        if (this.dryRun) {
            logArtifactDownload(gav, repo, this.p2Metadata, packaging, stagingDir);
            return;
        }

        getLog().info("====================================================");
        getLog().info("Downloading " + gav + " using Maven Artifact Resolver");
        getLog().info("====================================================");

        // Create target directory structure: staging/groupId/artifactId/version
        String groupPath = groupId.replace('.', '/');
        File targetDir = new File(new File(new File(stagingDir, groupPath), artifactId), projectVersion);
        if (!targetDir.mkdirs() && !targetDir.exists()) {
            throw new MojoFailureException("Failed to create target directory: " + targetDir);
        }

        // Create remote repository for Aether
        RemoteRepository remoteRepo = createRemoteRepository(repo);

        // Check if this is a reactor project - handle POM differently
        Model syntheticModel = new Model();
        syntheticModel.setGroupId(groupId);
        syntheticModel.setArtifactId(artifactId);
        syntheticModel.setVersion(projectVersion);

        // Download artifacts based on packaging type
        downloadArtifactsByPackaging(remoteRepo, groupId, artifactId, projectVersion, packaging, targetDir);
    }

    /**
     * Downloads artifacts based on packaging type using Maven Artifact Resolver.
     * 
     * @param remoteRepo The remote repository
     * @param groupId    The group ID
     * @param artifactId The artifact ID
     * @param version    The version
     * @param packaging  The packaging type
     * @param targetDir  The target directory
     * @throws MojoFailureException if a mandatory artifact fails to download
     */
    private void downloadArtifactsByPackaging(RemoteRepository remoteRepo, String groupId, String artifactId,
            String version, String packaging, File targetDir) throws MojoFailureException {

        downloadArtifactAndSidecars(new ArtifactDownloadContext(
                remoteRepo, groupId, artifactId, version, "pom", null, targetDir, true));

        // Download main artifact based on packaging
        if (ECLIPSE_REPOSITORY_PACKAGING.equals(packaging)) {
            // Eclipse repository produces ZIP artifacts
            downloadArtifactAndSidecars(new ArtifactDownloadContext(
                    remoteRepo, groupId, artifactId, version, "zip", null, targetDir, false));
        } else if (!POM_PACKAGING.equals(packaging)) {
            // Standard JAR packaging (includes eclipse-feature and eclipse-plugin)
            downloadArtifactAndSidecars(new ArtifactDownloadContext(
                    remoteRepo, groupId, artifactId, version, "jar", null, targetDir, false));
        }

        // Download sources and javadoc (not for eclipse-repository)
        if (!ECLIPSE_REPOSITORY_PACKAGING.equals(packaging)) {
            downloadArtifactAndSidecars(new ArtifactDownloadContext(
                    remoteRepo, groupId, artifactId, version, "jar", "sources", targetDir, false));
            downloadArtifactAndSidecars(new ArtifactDownloadContext(
                    remoteRepo, groupId, artifactId, version, "jar", "javadoc", targetDir, false));
        }

        // Download P2 metadata if needed
        boolean shouldIncludeP2 = this.p2Metadata || isEclipsePackaging(packaging);
        if (shouldIncludeP2) {
            downloadArtifactAndSidecars(new ArtifactDownloadContext(
                    remoteRepo, groupId, artifactId, version, "xml", "p2artifacts", targetDir, false));
            downloadArtifactAndSidecars(new ArtifactDownloadContext(
                    remoteRepo, groupId, artifactId, version, "xml", "p2metadata", targetDir, false));
        }

        // Validate that all mandatory artifacts were downloaded successfully
        validateMandatoryDownloads();
    }

    /**
     * Downloads an artifact along with its signature and checksum files.
     * 
     * @param context The download context containing all necessary parameters
     */
    private void downloadArtifactAndSidecars(ArtifactDownloadContext context) {

        // Download main artifact
        boolean success = downloadArtifactWithResolver(context.remoteRepo, context.groupId, context.artifactId,
                context.version, context.extension, context.classifier, context.targetDir);

        if (!success) {
            String coords = buildCoordinates(context.groupId, context.artifactId, context.version,
                    context.extension, context.classifier);
            if (context.isMandatory) {
                getLog().error("Failed to download mandatory artifact: " + coords);
                failedDownloads.add(coords);
                failedMandatoryDownloads.add(coords);
            } else {
                getLog().warn("Failed to download optional artifact: " + coords);
                failedDownloads.add(coords);
            }
            return;
        }

        // Download signature files if enabled
        if (this.downloadSignatures) {
            String sigExt = context.extension + ".asc";
            downloadArtifactWithResolver(context.remoteRepo, context.groupId, context.artifactId,
                    context.version, sigExt, context.classifier, context.targetDir);
        }

        // Download checksum files if enabled
        if (this.downloadChecksums) {
            downloadArtifactWithResolver(context.remoteRepo, context.groupId, context.artifactId,
                    context.version, context.extension + ".md5", context.classifier, context.targetDir);
            downloadArtifactWithResolver(context.remoteRepo, context.groupId, context.artifactId,
                    context.version, context.extension + ".sha1", context.classifier, context.targetDir);
        }

        if (this.downloadChecksums256) {
            downloadArtifactWithResolver(context.remoteRepo, context.groupId, context.artifactId,
                    context.version, context.extension + ".sha256", context.classifier, context.targetDir);
        }

        if (this.downloadChecksums512) {
            downloadArtifactWithResolver(context.remoteRepo, context.groupId, context.artifactId,
                    context.version, context.extension + ".sha512", context.classifier, context.targetDir);
        }
    }

    /**
     * Builds coordinate string for logging.
     */
    private String buildCoordinates(String groupId, String artifactId, String version, String extension,
            String classifier) {
        String coords = groupId + ":" + artifactId + ":" + version + ":" + extension;
        if (classifier != null && !classifier.isEmpty()) {
            coords += ":" + classifier;
        }
        return coords;
    }

    /**
     * Validates that all mandatory downloads succeeded.
     * 
     * @throws MojoFailureException if any mandatory artifacts failed to download
     */
    private void validateMandatoryDownloads() throws MojoFailureException {
        if (!failedMandatoryDownloads.isEmpty()) {
            StringBuilder errorMessage = new StringBuilder();
            errorMessage.append("Failed to download ").append(failedMandatoryDownloads.size())
                    .append(" mandatory artifact(s):\n");
            for (String coords : failedMandatoryDownloads) {
                errorMessage.append("  - ").append(coords).append("\n");
            }
            throw new MojoFailureException(errorMessage.toString());
        }
    }

    // ================================================================================================
    // UTILITY METHODS
    // ================================================================================================

    /**
     * Displays the current configuration and GAV coordinates to be downloaded.
     * 
     * @param gav The GAV (Group:Artifact:Version) array to display
     */
    private void showConfig(String[] gav) {
        getLog().info("GAV to download: " + String.join(":", gav));
        getLog().info(
                "Config: \n" +
                        "  ============== Remote Repository Configuration ===============\n" +
                        "         central.serverSyncId=" + this.serverSyncId + "\n" +
                        "         central.repositoryUrl=" + this.repositoryUrl + "\n" +
                        "         central.repositoryLayout=" + this.repositoryLayout + "\n" +
                        "  =============== GAV Configuration ===============\n" +
                        "         central.namespace=" + (this.namespace != null ? this.namespace : "default") + "\n" +
                        "         central.name=" + (this.name != null ? this.name : "default") + "\n" +
                        "         central.version=" + (this.version != null ? this.version : "default") + "\n" +
                        "  =============== File and Directory Configuration ===============\n" +
                        "         central.syncStagingDir="
                        + (this.syncStagingDir != null ? this.syncStagingDir : "default") + "\n" +
                        "         central.syncStagingDirName="
                        + (this.syncStagingDirName != null ? this.syncStagingDirName : "default") + "\n" +
                        "         central.syncBundleFile="
                        + (this.syncBundleFile != null ? this.syncBundleFile.getAbsolutePath() : "default") + "\n" +
                        "  =============== Execution Mode Configuration ===============\n" +
                        "         central.dryRun=" + this.dryRun + "\n" +
                        "         central.skipDownload=" + this.skipDownload + "\n" +
                        "  =============== Download Configuration ===============\n" +
                        "         central.downloadSignatures=" + this.downloadSignatures + "\n" +
                        "         central.downloadChecksums=" + this.downloadChecksums + "\n" +
                        "         central.downloadChecksums256=" + this.downloadChecksums256 + "\n" +
                        "         central.downloadChecksums512=" + this.downloadChecksums512 + "\n" +
                        "  =============== Output Configuration ===============\n" +
                        "         central.showMavenGoalOutput=" + this.showMavenGoalOutput + "\n" +
                        "  =============== Failure Handling Configuration ===============\n" +
                        "         central.failOnMissingSourcesJavadoc=" + this.failOnMissingSourcesJavadoc + "\n" +
                        "         central.failOnMissingSignatureFile=" + this.failOnMissingSignatureFile + "\n" +
                        "         central.failOnMissingChecksum=" + this.failOnMissingChecksum + "\n" +
                        "  =============== Artifact Processing Configuration ===============\n" +
                        "         central.p2Metadata=" + this.p2Metadata);
    }

    // ================================================================================================
    // DRY-RUN LOGGING METHODS
    // ================================================================================================

    /**
     * Logs artifact download operations in dry-run mode.
     */
    private void logArtifactDownload(String gav, Repository repo, boolean p2Metadata, String packaging,
            File stagingDir) {

        getLog().info("DRY-RUN: Would download artifacts for " + gav + " from " + repo.getUrl());
        getLog().info("DRY-RUN:   Step 1: dependency:get to local repository");

        // Build checksum suffix based on configuration
        StringBuilder checksumSuffix = new StringBuilder();
        if (this.downloadSignatures || this.downloadChecksums || this.downloadChecksums256
                || this.downloadChecksums512) {
            checksumSuffix.append(" (+");
            if (this.downloadSignatures) {
                checksumSuffix.append(" ").append(ASC_EXTENSION);
            }
            if (this.downloadChecksums) {
                checksumSuffix.append(", ").append(MD5_EXTENSION).append(", ").append(SHA1_EXTENSION);
            }
            if (this.downloadChecksums256) {
                checksumSuffix.append(", ").append(SHA256_EXTENSION);
            }
            if (this.downloadChecksums512) {
                checksumSuffix.append(", ").append(SHA512_EXTENSION);
            }
            checksumSuffix.append(")");
        }

        if (ECLIPSE_REPOSITORY_PACKAGING.equals(packaging)) {
            getLog().info("DRY-RUN:     - Main ZIP: " + gav + ZIP_SPEC + checksumSuffix);
        } else if (!POM_PACKAGING.equals(packaging)) {
            getLog().info("DRY-RUN:     - Main JAR: " + gav + JAR_SPEC + checksumSuffix);
        }
        getLog().info("DRY-RUN:     - POM file: " + gav + POM_SPEC + checksumSuffix);

        if (!ECLIPSE_REPOSITORY_PACKAGING.equals(packaging)) {
            getLog().info("DRY-RUN:     - Sources JAR: " + gav + JAR_SOURCES_SPEC + checksumSuffix);
            getLog().info("DRY-RUN:     - Javadoc JAR: " + gav + JAR_JAVADOC_SPEC + checksumSuffix);
        }

        if (POM_PACKAGING.equals(packaging)) {
            getLog().info("DRY-RUN:     - Note: POM modules may not have sources/javadoc (will warn if missing)");
        } else if (isEclipsePackaging(packaging)) {
            getLog().info(
                    "DRY-RUN:     - Note: " + packaging
                            + " modules typically don't have sources/javadoc (will warn if missing)");
        }

        // Show P2 metadata info for Eclipse packagings or when explicitly requested
        if (p2Metadata || isEclipsePackaging(packaging)) {
            getLog().info("DRY-RUN:     - P2 Artifacts metadata: " + gav + P2_ARTIFACTS_SPEC + checksumSuffix);
            getLog().info("DRY-RUN:     - P2 Content metadata: " + gav + P2_METADATA_SPEC + checksumSuffix);
            if (isEclipsePackaging(packaging) && !p2Metadata) {
                getLog().info(
                        "DRY-RUN:     - Note: P2 metadata automatically included for " + packaging + " packaging");
            }
        }

        if (this.downloadSignatures || this.downloadChecksums || this.downloadChecksums256
                || this.downloadChecksums512) {
            getLog().info("DRY-RUN:   Note: GPG signatures and checksums are optional");
        }
        getLog().info("DRY-RUN:   Step 2: dependency:copy to staging directory");
        getLog().info("DRY-RUN:     - Target directory: " + stagingDir.getAbsolutePath());
    }

    /**
     * Logs Maven execution context information for debugging purposes.
     */
    private void logMavenExecutionContext() {
        getLog().info("=== Maven Execution Context ===");

        if (this.project != null) {
            getLog().info("Project: " + this.project.getGroupId() + ":" + this.project.getArtifactId() + ":"
                    + this.project.getVersion());
            getLog().info("Project Build Directory: "
                    + (this.project.getBuild() != null ? this.project.getBuild().getDirectory() : "null"));
            getLog().info("Project is execution root: " + this.project.isExecutionRoot());
        } else {
            getLog().info("Project: null (standalone execution)");
        }

        if (this.session != null) {
            getLog().info("Session requested project: "
                    + (this.session.getRequest() != null && this.session.getRequest().isProjectPresent()));
            getLog().info("Session current project: "
                    + (this.session.getCurrentProject() != null ? this.session.getCurrentProject().getArtifactId()
                            : "null"));
            getLog().info("Local repository: "
                    + (this.session.getLocalRepository() != null ? this.session.getLocalRepository().getBasedir()
                            : "null"));
        } else {
            getLog().info("Session: null");
        }

        if (this.mojoExecution != null) {
            getLog().info("Mojo execution goal: " + this.mojoExecution.getGoal());
            getLog().info("Mojo execution lifecycle phase: " + this.mojoExecution.getLifecyclePhase());
        } else {
            getLog().info("Mojo execution: null");
        }

        if (this.reactorProjects != null) {
            getLog().info("Reactor projects count: " + this.reactorProjects.size());
        } else {
            getLog().info("Reactor projects: null");
        }
        getLog().info("=== End Maven Execution Context ===");
    }
}