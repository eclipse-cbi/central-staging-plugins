/*
 * Copyright (c) 2025 Eclipse Foundation and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * // Some portions generated by Co-Pilot
 */

package org.eclipse.cbi.central;

import okhttp3.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.util.Map;

/**
 * Central Portal API Client for Maven Central staging operations.
 * 
 * This client provides a Java interface to the Central Publisher API available at
 * https://central.sonatype.com/api/v1/publisher. All operations are based on
 * Sonatype's staging model for Maven Central publication.
 * 
 * The staging model workflow:
 * 1. Upload artifacts to staging area
 * 2. Validation by Sonatype (signatures, checksums, metadata)
 * 3. Publication to make artifacts publicly available
 * 4. Optional cleanup of staging deployments
 * 
 * @see <a href="https://central.sonatype.com/api-doc">Central Publisher API Documentation</a>
 */
public class CentralPortalClient {
    // Context strings for error descriptions
    private static final String CTX_DEPLOYMENT_NOT_FOUND = "Deployment not found";
    private static final String CTX_CHECK_PUBLISHED = "Check published";
    private static final String CTX_GET_DEPLOYMENT_STATUS = "Get deployment status";
    private static final String CTX_PUBLISH_DEPLOYMENT = "Publish deployment";
    private static final String CTX_LIST_DEPLOYMENTS = "List deployments";
    private static final String CTX_UPLOAD_BUNDLE = "Upload bundle";
    // Generic error codes with parameterized descriptions
    private static final Map<Integer, String> ERROR_CODES = Map.of(
            400, "Bad request",
            401, "Unauthorized",
            403, "Forbidden",
            404, "Not found",
            500, "Internal server error");

    /**
     * Returns a descriptive error message for a given HTTP code and context.
     */
    private String errorDescription(int code, String context) {
        String base = ERROR_CODES.getOrDefault(code, "Unexpected error");
        if (context != null && !context.isEmpty()) {
            return base + " - " + context;
        }
        return base;
    }

    private static final String DEFAULT_BASE_URL = "https://central.sonatype.com/api/v1/publisher";
    private final String baseUrl;
    private static final String HEADER_AUTH = "Authorization";
    private static final String HEADER_ACCEPT = "Accept";
    private static final String MEDIA_JSON = "application/json";
    private final String bearerToken;
    private final OkHttpClient client;
    private final ObjectMapper objectMapper;

    /**
     * Creates a new Central Portal API client with default base URL.
     * 
     * @param bearerToken Authentication token for Central Publisher API
     */
    public CentralPortalClient(String bearerToken) {
        this(bearerToken, DEFAULT_BASE_URL);
    }

    /**
     * Creates a new Central Portal API client with custom base URL.
     * 
     * @param bearerToken Authentication token for Central Publisher API
     * @param baseUrl Custom API base URL (defaults to https://central.sonatype.com/api/v1/publisher)
     */
    public CentralPortalClient(String bearerToken, String baseUrl) {
        this.bearerToken = bearerToken;
        this.baseUrl = baseUrl != null && !baseUrl.isEmpty() ? baseUrl : DEFAULT_BASE_URL;
        this.client = new OkHttpClient();
        this.objectMapper = new ObjectMapper();
    }

    /**
     * Creates a base HTTP request builder with authentication and JSON headers.
     */
    private Request.Builder baseRequest(String url) {
        return new Request.Builder()
                .url(url)
                .addHeader(HEADER_AUTH, "Bearer " + bearerToken)
                .addHeader(HEADER_ACCEPT, MEDIA_JSON);
    }

    /**
     * Handles HTTP responses, parses JSON if expected, and throws exceptions for
     * error codes.
     *
     * @param response      The HTTP response
     * @param errorMessages Map of error codes to messages
     * @param expectJson    Whether to parse the response body as JSON
     * @return Parsed response as a Map
     * @throws IOException if an error or unexpected code occurs
     */
    private Map<String, Object> handleResponse(Response response, Map<Integer, String> errorMessages,
            boolean expectJson) throws IOException {
        int code = response.code();
        String body = response.body() != null ? response.body().string() : "";
        if (code == 200 && expectJson) {
            return objectMapper.readValue(body, Map.class);
        } else if (code == 204 && !expectJson) {
            return Map.of("success", true, "message", "Deployment published successfully.");
        } else if (errorMessages.containsKey(code)) {
            throw new IOException(errorMessages.get(code) + " (" + code + "): " + body);
        } else {
            throw new IOException("Unexpected HTTP code " + code + ": " + body);
        }
    }

    /**
     * Checks if a component is published in Central for the given namespace, name,
     * and version.
     *
     * @param namespace The namespace (groupId)
     * @param name      The name (artifactId)
     * @param version   The version
     * @return Publication status as a Map
     * @throws IOException if the request fails
     */
    public Map<String, Object> checkPublished(String namespace, String name, String version) throws IOException {
        String url = baseUrl + "/published?namespace=" + namespace + "&name=" + name + "&version=" + version;
        Request request = baseRequest(url).get().build();
        try (Response response = client.newCall(request).execute()) {
            return handleResponse(response, Map.of(
                    400, errorDescription(400, CTX_CHECK_PUBLISHED),
                    401, errorDescription(401, CTX_CHECK_PUBLISHED),
                    403, errorDescription(403, CTX_CHECK_PUBLISHED),
                    500, errorDescription(500, CTX_CHECK_PUBLISHED)), true);
        }
    }

    /**
     * Gets the status of a deployment by its deploymentId.
     *
     * @param deploymentId The deployment ID
     * @return Deployment status as a Map
     * @throws IOException if the request fails
     */
    public Map<String, Object> getDeploymentStatus(String deploymentId) throws IOException {
        String url = baseUrl + "/status?id=" + deploymentId;
        Request request = baseRequest(url).post(RequestBody.create(new byte[0])).build();
        try (Response response = client.newCall(request).execute()) {
            return handleResponse(response, Map.of(
                    400, errorDescription(400, CTX_GET_DEPLOYMENT_STATUS),
                    401, errorDescription(401, CTX_GET_DEPLOYMENT_STATUS),
                    403, errorDescription(403, CTX_GET_DEPLOYMENT_STATUS),
                    404, errorDescription(404, CTX_DEPLOYMENT_NOT_FOUND),
                    500, errorDescription(500, CTX_GET_DEPLOYMENT_STATUS)), true);
        }
    }

    /**
     * Publishes a deployment by its deploymentId.
     *
     * @param deploymentId The deployment ID
     * @return Result of the publish operation as a Map
     * @throws IOException if the request fails
     */
    public Map<String, Object> publishDeployment(String deploymentId) throws IOException {
        String url = baseUrl + "/deployment/" + deploymentId;
        Request request = baseRequest(url).post(RequestBody.create(new byte[0])).build();
        try (Response response = client.newCall(request).execute()) {
            return handleResponse(response, Map.of(
                    400, errorDescription(400, CTX_PUBLISH_DEPLOYMENT),
                    401, errorDescription(401, CTX_PUBLISH_DEPLOYMENT),
                    403, errorDescription(403, CTX_PUBLISH_DEPLOYMENT),
                    404, errorDescription(404, CTX_DEPLOYMENT_NOT_FOUND),
                    500, errorDescription(500, CTX_PUBLISH_DEPLOYMENT)), false);
        }
    }

    // Drop a deployment (FAILED or VALIDATED state)
    /**
     * Drops a deployment (FAILED or VALIDATED state) by its deploymentId.
     *
     * @param deploymentId The deployment ID
     * @return Result of the drop operation as a Map
     * @throws IOException if the request fails
     */
    public Map<String, Object> dropDeployment(String deploymentId) throws IOException {
        String url = baseUrl + "/deployment/" + deploymentId;
        Request request = baseRequest(url).delete().build();
        try (Response response = client.newCall(request).execute()) {
            int code = response.code();
            String body = response.body() != null ? response.body().string() : "";
            if (code == 204) {
                return Map.of("success", true, "message", "Deployment dropped successfully.");
            } else if (ERROR_CODES.containsKey(code)) {
                throw new IOException(errorDescription(code, "Drop deployment") + " (" + code + "): " + body);
            } else {
                throw new IOException("Unexpected HTTP code " + code + ": " + body);
            }
        }
    }

    // List deployments for a given pathStarting (namespace)
    /**
     * Lists deployments for a given namespace (pathStarting) with pagination and
     * sorting.
     *
     * @param pathStarting  The namespace (groupId)
     * @param page          Page number
     * @param size          Page size
     * @param sortField     Field to sort by
     * @param sortDirection Sort direction (asc/desc)
     * @return List of deployments as a Map
     * @throws IOException if the request fails
     */
    public Map<String, Object> listDeployments(String pathStarting, int page, int size, String sortField,
            String sortDirection) throws IOException {
        String url = baseUrl + "/deployments/files";
        MediaType jsonType = MediaType.parse(MEDIA_JSON);
        String payload = String.format(
                "{\"page\":%d,\"size\":%d,\"sortField\":\"%s\",\"sortDirection\":\"%s\",\"pathStarting\":\"%s\"}",
                page, size, sortField, sortDirection, pathStarting);
        RequestBody body = RequestBody.create(payload, jsonType);
        Request request = baseRequest(url)
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            return handleResponse(response, Map.of(
                    400, errorDescription(400, CTX_LIST_DEPLOYMENTS),
                    401, errorDescription(401, CTX_LIST_DEPLOYMENTS),
                    403, errorDescription(403, CTX_LIST_DEPLOYMENTS),
                    500, errorDescription(500, CTX_LIST_DEPLOYMENTS)), true);
        }
    }

    /**
     * Uploads a bundle (zip file) to Central Portal staging area.
     * 
     * This operation corresponds to the staging phase of Sonatype's publication model.
     * The uploaded bundle enters a staging state where it undergoes validation
     * before it can be published to Maven Central.
     * 
     * API Endpoint: POST /upload
     * 
     * @param bundleFile     The path to the zip file to upload
     * @param bundleName     The name for the bundle (for identification)
     * @param publishingType The publishing type (e.g., "USER_MANAGED" for manual publishing)
     * @return The deployment ID as a string (used for subsequent operations)
     * @throws IOException if the upload fails or API returns an error
     */
    public String uploadBundle(java.nio.file.Path bundleFile, String bundleName, String publishingType) throws IOException {
        String url = baseUrl + "/upload?name=" + bundleName + "&publishingType=" + publishingType;
        
        // Create multipart form data for file upload
        RequestBody fileBody = RequestBody.create(bundleFile.toFile(), MediaType.parse("application/zip"));
        RequestBody formBody = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("bundle", bundleFile.getFileName().toString(), fileBody)
                .build();

        Request request = new Request.Builder()
                .url(url)
                .addHeader(HEADER_AUTH, "Bearer " + bearerToken)
                .addHeader("accept", "text/plain")
                .post(formBody)
                .build();

        try (Response response = client.newCall(request).execute()) {
            int code = response.code();
            String body = response.body() != null ? response.body().string() : "";
            
            if (code == 201 || code == 200) {
                // The deployment ID is returned as plain text
                return body.trim();
            } else if (code == 400) {
                throw new IOException("Wrong authorization data (user/password or token) - " + CTX_UPLOAD_BUNDLE + " (" + code + "): " + body);
            } else if (code == 401) {
                throw new IOException("The user does not have an active session or is not authenticated - " + CTX_UPLOAD_BUNDLE + " (" + code + "): " + body);
            } else if (code == 403) {
                throw new IOException("The user is not authorized to perform this action - " + CTX_UPLOAD_BUNDLE + " (" + code + "): " + body);
            } else if (code == 500) {
                throw new IOException("Return error message on bundle upload - " + CTX_UPLOAD_BUNDLE + " (" + code + "): " + body);
            } else {
                throw new IOException("Unexpected HTTP code " + code + ": " + body);
            }
        }
    }
}
